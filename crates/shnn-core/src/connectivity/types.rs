//! Common types for network connectivity implementations
//!
//! This module defines shared data structures used across different
//! connectivity implementations.

use crate::{
    spike::NeuronId,
    time::Time,
};
use core::fmt;

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

/// Generic connection identifier
///
/// This trait allows different connectivity structures to define their own
/// connection identification schemes while maintaining type safety.
pub trait ConnectionId: Clone + fmt::Debug + PartialEq + Eq {
    /// Create a connection ID from raw components
    fn from_raw(data: &[u8]) -> Result<Self, &'static str> where Self: Sized;
    
    /// Convert connection ID to raw bytes
    fn to_raw(&self) -> Vec<u8>;
    
    /// Get a human-readable string representation
    fn display_string(&self) -> String;
}

/// Spike routing information
///
/// Contains all information needed to route a spike from a source to its targets,
/// including weights, delivery times, and connection metadata.
#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SpikeRoute {
    /// Source connection that triggered this route
    pub source_connection: Vec<u8>, // Generic connection ID as bytes
    /// Target neurons for this route
    pub targets: Vec<NeuronId>,
    /// Weights for each target (parallel to targets vector)
    pub weights: Vec<f32>,
    /// Delivery time for the spike
    pub delivery_time: Time,
    /// Optional delay for each target
    pub delays: Option<Vec<Time>>,
    /// Metadata about the routing decision
    pub metadata: RouteMetadata,
}

impl SpikeRoute {
    /// Create a new spike route
    pub fn new(
        source_connection: Vec<u8>,
        targets: Vec<NeuronId>,
        weights: Vec<f32>,
        delivery_time: Time,
    ) -> Result<Self, &'static str> {
        if targets.len() != weights.len() {
            return Err("Targets and weights vectors must have the same length");
        }
        
        if targets.is_empty() {
            return Err("Route must have at least one target");
        }
        
        Ok(Self {
            source_connection,
            targets,
            weights,
            delivery_time,
            delays: None,
            metadata: RouteMetadata::default(),
        })
    }
    
    /// Create a route with individual delays
    pub fn with_delays(
        source_connection: Vec<u8>,
        targets: Vec<NeuronId>,
        weights: Vec<f32>,
        delivery_time: Time,
        delays: Vec<Time>,
    ) -> Result<Self, &'static str> {
        if targets.len() != weights.len() || targets.len() != delays.len() {
            return Err("Targets, weights, and delays vectors must have the same length");
        }
        
        if targets.is_empty() {
            return Err("Route must have at least one target");
        }
        
        Ok(Self {
            source_connection,
            targets,
            weights,
            delivery_time,
            delays: Some(delays),
            metadata: RouteMetadata::default(),
        })
    }
    
    /// Get the number of targets in this route
    pub fn target_count(&self) -> usize {
        self.targets.len()
    }
    
    /// Get the total weight (sum of all individual weights)
    pub fn total_weight(&self) -> f32 {
        self.weights.iter().sum()
    }
    
    /// Get the average weight
    pub fn average_weight(&self) -> f32 {
        if self.weights.is_empty() {
            0.0
        } else {
            self.total_weight() / self.weights.len() as f32
        }
    }
    
    /// Get effective delivery time for a specific target
    pub fn target_delivery_time(&self, target_index: usize) -> Option<Time> {
        if target_index >= self.targets.len() {
            return None;
        }
        
        if let Some(ref delays) = self.delays {
            Some(self.delivery_time + crate::time::Duration::from_nanos(delays[target_index].as_nanos()))
        } else {
            Some(self.delivery_time)
        }
    }
}

/// Metadata about a spike route
#[derive(Debug, Clone, PartialEq, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct RouteMetadata {
    /// Route generation timestamp
    pub timestamp: Time,
    /// Whether this route was generated by plasticity
    pub plastic: bool,
    /// Route priority (higher = more important)
    pub priority: u8,
    /// Custom metadata tags
    pub tags: Vec<String>,
}

/// Network connectivity statistics
///
/// Provides comprehensive information about the structure and properties
/// of a connectivity network.
#[derive(Debug, Clone, PartialEq, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ConnectivityStats {
    /// Total number of connections
    pub connection_count: usize,
    /// Total number of unique neurons
    pub node_count: usize,
    /// Average degree (connections per neuron)
    pub average_degree: f32,
    /// Maximum degree (most connected neuron)
    pub max_degree: u32,
    /// Minimum degree (least connected neuron)
    pub min_degree: u32,
    /// Total weight sum across all connections
    pub total_weight: f32,
    /// Average weight per connection
    pub average_weight: f32,
    /// Memory usage in bytes (estimated)
    pub memory_usage: usize,
    /// Whether the network has cycles
    pub has_cycles: Option<bool>,
    /// Network density (actual connections / possible connections)
    pub density: f32,
    /// Additional implementation-specific statistics
    pub custom_stats: Vec<(String, f32)>,
}

impl ConnectivityStats {
    /// Create new empty statistics
    pub fn new() -> Self {
        Self::default()
    }
    
    /// Update statistics with new connection count
    pub fn update_connection_count(&mut self, count: usize) {
        self.connection_count = count;
        self._recalculate_derived_stats();
    }
    
    /// Update statistics with new node count
    pub fn update_node_count(&mut self, count: usize) {
        self.node_count = count;
        self._recalculate_derived_stats();
    }
    
    /// Add a custom statistic
    pub fn add_custom_stat(&mut self, name: String, value: f32) {
        // Update existing stat or add new one
        if let Some(existing) = self.custom_stats.iter_mut().find(|(n, _)| n == &name) {
            existing.1 = value;
        } else {
            self.custom_stats.push((name, value));
        }
    }
    
    /// Get a custom statistic by name
    pub fn get_custom_stat(&self, name: &str) -> Option<f32> {
        self.custom_stats.iter()
            .find(|(n, _)| n == name)
            .map(|(_, v)| *v)
    }
    
    /// Calculate network efficiency metrics
    pub fn efficiency_metrics(&self) -> EfficiencyMetrics {
        EfficiencyMetrics {
            sparsity: 1.0 - self.density,
            degree_variance: self._calculate_degree_variance(),
            weight_efficiency: if self.connection_count > 0 {
                self.total_weight / self.connection_count as f32
            } else {
                0.0
            },
            memory_per_connection: if self.connection_count > 0 {
                self.memory_usage / self.connection_count
            } else {
                0
            },
        }
    }
    
    /// Recalculate derived statistics
    fn _recalculate_derived_stats(&mut self) {
        if self.node_count > 0 {
            self.average_degree = self.connection_count as f32 / self.node_count as f32;
            
            // Calculate density for directed graph
            let max_possible_connections = self.node_count * (self.node_count - 1);
            self.density = if max_possible_connections > 0 {
                self.connection_count as f32 / max_possible_connections as f32
            } else {
                0.0
            };
        }
        
        if self.connection_count > 0 {
            self.average_weight = self.total_weight / self.connection_count as f32;
        }
    }
    
    /// Calculate degree variance (placeholder - would need actual degree data)
    fn _calculate_degree_variance(&self) -> f32 {
        // This is a simplified calculation
        // In practice, we'd need access to the actual degree distribution
        if self.max_degree > 0 && self.min_degree < self.max_degree {
            (self.max_degree - self.min_degree) as f32 / self.max_degree as f32
        } else {
            0.0
        }
    }
}

/// Network efficiency metrics
#[derive(Debug, Clone, PartialEq)]
pub struct EfficiencyMetrics {
    /// Network sparsity (1 - density)
    pub sparsity: f32,
    /// Degree distribution variance
    pub degree_variance: f32,
    /// Weight utilization efficiency
    pub weight_efficiency: f32,
    /// Memory usage per connection
    pub memory_per_connection: usize,
}

impl fmt::Display for ConnectivityStats {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "ConnectivityStats {{ connections: {}, nodes: {}, avg_degree: {:.2}, density: {:.3}, memory: {}KB }}",
            self.connection_count,
            self.node_count,
            self.average_degree,
            self.density,
            self.memory_usage / 1024
        )
    }
}

/// Error types specific to connectivity operations
#[derive(Debug, Clone, PartialEq)]
pub enum ConnectivityError {
    /// Invalid connection parameters
    InvalidConnection {
        /// Reason for the invalid connection
        reason: &'static str,
    },
    /// Connection not found
    ConnectionNotFound {
        /// The connection identifier that was not found
        connection_id: Vec<u8>,
    },
    /// Node not found
    NodeNotFound {
        /// The node ID that was not found
        node_id: u32,
    },
    /// Network structure validation failed
    ValidationFailed {
        /// Reason for validation failure
        reason: &'static str,
    },
    /// Memory allocation failed
    MemoryError {
        /// The size that was requested but could not be allocated
        requested_size: usize,
    },
    /// Serialization/deserialization error
    #[cfg(feature = "serde")]
    SerializationError {
        message: String,
    },
}

impl fmt::Display for ConnectivityError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidConnection { reason } => {
                write!(f, "Invalid connection: {}", reason)
            }
            Self::ConnectionNotFound { connection_id } => {
                write!(f, "Connection not found: {:?}", connection_id)
            }
            Self::NodeNotFound { node_id } => {
                write!(f, "Node not found: {}", node_id)
            }
            Self::ValidationFailed { reason } => {
                write!(f, "Network validation failed: {}", reason)
            }
            Self::MemoryError { requested_size } => {
                write!(f, "Memory allocation failed for {} bytes", requested_size)
            }
            #[cfg(feature = "serde")]
            Self::SerializationError { message } => {
                write!(f, "Serialization error: {}", message)
            }
        }
    }
}

#[cfg(feature = "std")]
impl std::error::Error for ConnectivityError {}

impl From<crate::error::SHNNError> for ConnectivityError {
    fn from(err: crate::error::SHNNError) -> Self {
        Self::ValidationFailed {
            reason: "SHNN error occurred"
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::time::Time;

    #[test]
    fn test_spike_route_creation() {
        let targets = vec![NeuronId::new(1), NeuronId::new(2)];
        let weights = vec![0.5, 0.7];
        let connection_id = vec![1, 2, 3, 4];
        let delivery_time = Time::from_millis(10);
        
        let route = SpikeRoute::new(
            connection_id.clone(),
            targets.clone(),
            weights.clone(),
            delivery_time,
        ).expect("Should create valid route");
        
        assert_eq!(route.targets, targets);
        assert_eq!(route.weights, weights);
        assert_eq!(route.target_count(), 2);
        assert_eq!(route.total_weight(), 1.2);
        assert_eq!(route.average_weight(), 0.6);
    }
    
    #[test]
    fn test_spike_route_with_delays() {
        let targets = vec![NeuronId::new(1)];
        let weights = vec![1.0];
        let delays = vec![Time::from_millis(5)];
        let connection_id = vec![1];
        let delivery_time = Time::from_millis(10);
        
        let route = SpikeRoute::with_delays(
            connection_id,
            targets,
            weights,
            delivery_time,
            delays,
        ).expect("Should create valid route with delays");
        
        assert_eq!(
            route.target_delivery_time(0),
            Some(Time::from_millis(15))
        );
    }
    
    #[test]
    fn test_connectivity_stats() {
        let mut stats = ConnectivityStats::new();
        stats.update_connection_count(100);
        stats.update_node_count(50);
        
        assert_eq!(stats.connection_count, 100);
        assert_eq!(stats.node_count, 50);
        assert_eq!(stats.average_degree, 2.0);
        
        stats.add_custom_stat("test_metric".to_string(), 42.0);
        assert_eq!(stats.get_custom_stat("test_metric"), Some(42.0));
    }
    
    #[test]
    fn test_invalid_spike_route() {
        let targets = vec![NeuronId::new(1)];
        let weights = vec![0.5, 0.7]; // Mismatched length
        let connection_id = vec![1];
        let delivery_time = Time::from_millis(10);
        
        let result = SpikeRoute::new(connection_id, targets, weights, delivery_time);
        assert!(result.is_err());
    }
}